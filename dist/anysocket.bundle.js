var AnySocket;AnySocket=(()=>{var e={147:(e,t,s)=>{const n=window.crypto||window.msCrypto;if(!n)throw new Error("Crypto is not supported in this browser!");const i=s(20),r="P-521";e.exports=new class{randomBytes(e){let t=new Uint8Array(e);for(let s=0;s<e;s+=65536)n.getRandomValues(t.subarray(s,s+Math.min(e-s,65536)));return t}createECDH(){return new Promise((async(e,t)=>{window.crypto.subtle.generateKey({name:"ECDH",namedCurve:r},!1,["deriveKey","deriveBits"]).then((function(t){e({generateKeys:()=>new Promise(((e,s)=>{window.crypto.subtle.exportKey("raw",t.publicKey).then((function(t){t=new Uint8Array(t),e(t)})).catch((function(e){s(e)}))})),computeSecret:e=>new Promise(((s,n)=>{window.crypto.subtle.importKey("raw",e,{name:"ECDH",namedCurve:r},!1,[]).then((function(e){window.crypto.subtle.deriveBits({name:"ECDH",namedCurve:r,public:e},t.privateKey,512).then((e=>{e=new Uint8Array(e),s(i.bufferToHex(e))}))})).catch((function(e){n(e)}))}))})})).catch((function(e){t(e)}))}))}pbkdf2Sync(e,t,s,n,r){let o={sha256:"SHA-256"};if(!o[r])throw new Error("Invalid algorithm "+r);return r=o[r],new Promise((async(o,c)=>{e instanceof CryptoKey||(e=await window.crypto.subtle.importKey("raw",i.utf8Encode(e),{name:"PBKDF2"},!1,["deriveKey","deriveBits"])),window.crypto.subtle.deriveBits({name:"PBKDF2",salt:i.utf8Encode(t),iterations:s,hash:{name:r}},e,8*n).then((function(e){o(new Uint8Array(e))})).catch((function(e){c(e)}))}))}}},954:e=>{e.exports=()=>()=>{}},267:e=>{e.exports=class{constructor(){this.callbacks={},this.callbacks_once={}}on(e,t){this.callbacks[e]||(this.callbacks[e]=[]),this.callbacks[e].push(t)}once(e,t){this.callbacks_once[e]||(this.callbacks_once[e]=[]),this.callbacks_once[e].push(t)}emit(e,...t){let s=this.callbacks[e];s&&s.forEach((e=>e(...t))),s=this.callbacks_once[e],s&&(s.forEach((e=>e(...t))),delete this.callbacks_once[e])}}},661:(e,t,s)=>{const n=s(510),i=s(20);n.encryptAES=(e,t)=>new Promise(((s,n)=>{window.crypto.subtle.importKey("raw",i.bufferFromHex(e),{name:"AES-CBC",length:256},!1,["encrypt"]).then((e=>{let r=window.crypto.getRandomValues(new Uint8Array(16));window.crypto.subtle.encrypt({name:"AES-CBC",iv:r},e,i.bufferFromString(t)).then((function(e){s(i.bufferToHex(r)+i.bufferToHex(new Uint8Array(e)))})).catch((function(e){n(e)}))})).catch(n)})),n.decryptAES=(e,t)=>new Promise(((s,n)=>{window.crypto.subtle.importKey("raw",i.bufferFromHex(e),{name:"AES-CBC",length:256},!1,["decrypt"]).then((e=>{window.crypto.subtle.decrypt({name:"AES-CBC",iv:i.bufferFromHex(t.substr(0,32))},e,i.bufferFromHex(t.substr(32))).then((function(e){s(i.bufferToString(new Uint8Array(e)))})).catch((e=>{n(e)}))})).catch((e=>{n(e)}))})),e.exports=n},20:e=>{e.exports={utf8Encode(e){let t=[],s=e.length,n=0;for(;n<s;){let s=e.codePointAt(n),i=0,r=0;for(s<=127?(i=0,r=0):s<=2047?(i=6,r=192):s<=65535?(i=12,r=224):s<=2097151&&(i=18,r=240),t.push(r|s>>i),i-=6;i>=0;)t.push(128|s>>i&63),i-=6;n+=s>=65536?2:1}return new Uint8Array(t)},bufferFromString(e){let t=new ArrayBuffer(e.length),s=new Uint8Array(t);for(let t=0,n=e.length;t<n;t++)s[t]=e.charCodeAt(t);return t},bufferToString(e){let t="";if(e){let s=new Uint8Array(e);for(let e=0;e<s.byteLength;e++)t+=String.fromCharCode(s[e])}return t},bufferToHex(e){return e.reduce(((e,t)=>e+this.i2hex(t)),"")},i2hex:e=>("0"+e.toString(16)).slice(-2),bufferFromHex(e){let t=new Uint8Array(e.length/2);for(let s=0;s<e.length;s+=2)t[s/2]=parseInt(e.substring(s,s+2),16);return t}}},966:e=>{e.exports=class{constructor(...e){this.ws=new WebSocket(...e)}on(e,t){switch(e){case"open":this.ws.onopen=t;break;case"error":this.ws.onerror=t;break;case"message":this.ws.onmessage=e=>{t(e.data)};break;case"close":this.ws.onclose=t;break;default:throw new Error("Not implemented in browser! ("+e+")")}}send(...e){this.ws.send(e)}close(){this.ws.close()}}},506:(e,t,s)=>{const n=s(100),i=s(555);n.Transport={LOCAL:s(870),WS:s(866)},n.Utils=s(661),n.Packer={pack:i.packBytes.bind(i),unpack:i.unpackBytes.bind(i)},n.tmp=s(20),e.exports=n},555:(e,t,s)=>{const n=s(20);e.exports=new class{packInt16(e){const t=new ArrayBuffer(2);return new DataView(t).setInt16(0,e,!1),String.fromCharCode.apply(String,new Uint8Array(t))}unpackInt16(e){const t=new ArrayBuffer(2),s=new Uint8Array(t);for(let t in e)s[t]=e.charCodeAt(t);return new DataView(t).getInt16(0)}packHex(e){let t="";for(let s=0;s<e.length;s+=2)t+=String.fromCharCode(parseInt(e.substr(s,2),16));return t}unpackHex(e){let t="";for(let s=0;s<e.length;s++){let n=Number(e.charCodeAt(s)).toString(16);t+=1===n.length?"0"+n:n}return t}packBytes(e){if(!(e instanceof ArrayBuffer||e instanceof Uint8Array))throw new Error("packBytes requires ArrayBuffer or UInt8Array");return n.bufferToString(e)}unpackBytes(e){return n.bufferFromString(e)}}},717:(e,t,s)=>{s(954)("AnyPacket");const n=Symbol("send function");e.exports=class{constructor(e,t,s){this.peer=e,this.seq=t.seq,this.msg=t.data,this[n]=s}reply(e){this[n](e,this.seq)}}},155:(e,t,s)=>{const n=s(954)("AnyPeer"),i=s(501),r=s(267),o=s(558),c=s(717),a=Symbol("private protocol"),h=Symbol("packets"),l=Symbol("links"),u=Symbol("heartbeat raw"),d=function(e){return!0===e||!1===e||"[object Boolean]"===toString.call(e)};e.exports=class extends r{constructor(e){super(),this[l]={},this[a]=e,this[h]={},this.id=e.peerID,this.lag=-1,this.connectionID=e.connectionID,this._heartbeat=!1,this.options=e.options;const t={get:(e,s)=>{const n=e[s];return null!=n?n:(e.path||(e.path=[]),e.path.push(s),new Proxy(e,{get:t.get,apply:(e,t,s)=>{let n=e.path;return e.path=[],new Promise(((e,t)=>{const r=o.data({type:i.INTERNAL_PACKET_TYPE.RPC,method:n,params:s||null}).setType(i.PACKET_TYPE.INTERNAL);this._send(r,!0).then((t=>{e(t.msg)})).catch((e=>{t(r.msg)}))}))}}))}};this.rpc=new Proxy((()=>{}),t),e.on("internal",this.onInternalComs.bind(this)),e.on("message",this.onMessage.bind(this)),e.on("e2e",(()=>{this.onE2E(),this.heartbeat()})),e.on("disconnected",((e,t)=>{this.emit("disconnected",e,t)}))}isProxy(){return this[a].isProxy()}heartbeat(e){if(!(this.options.heartbeatInterval<=0||this.options.heartbeatTimeout<=0))return e?new Promise(((e,t)=>{this[u]().then((()=>{e(this)})).catch((e=>{t(this,e)}))})):void(this.isProxy()||(this._heartbeat&&clearTimeout(this._heartbeat),this._heartbeat=setTimeout((()=>{this[u]().then((()=>{this.heartbeat()})).catch((()=>{}))}),this[a].options.heartbeatInterval)))}[u](){return new Promise(((e,t)=>{const s=(new Date).getTime(),r=o.data().setType(i.PACKET_TYPE.HEARTBEAT);this._send(r,!0,this[a].options.heartbeatTimeout).then((()=>{this.lag=(new Date).getTime()-s,e(),this.emit("heartbeat",this)})).catch((e=>{n("Heartbeat Error:",e),this.disconnect(e),t(e)}))}))}addLink(e){this[l][e.id]=e}removeLink(e){delete this[l][e.id]}getLinks(){return this[l]}e2e(){clearTimeout(this._heartbeat),this[a].e2e()}isE2EEnabled(){return this[a].peer.hasE2EEnabled()}send(e,t,s){const n=o.data(e).setType(i.PACKET_TYPE.LINK);return this._send(n,t,s)}forward(e){this[a].forward(e)}sendInternal(e,t,s){const n=o.data(e).setType(i.PACKET_TYPE.INTERNAL);return this._send(n,t,s)}onMessage(e,t){this.heartbeat(),t.seq<0?this._resolveReply(t)||n("Dropped reply "+t.seq+". Delivered after Timeout"):this.emit("message",new c(this,t,this.send.bind(this)))}onE2E(){this.emit("e2e",this)}onInternalComs(e,t){if(t.seq<0)this._resolveReply(t)||n("Dropped reply "+t.seq+". Delivered after Timeout");else if(t.type==i.PACKET_TYPE.HEARTBEAT){const e=o.data().setType(i.PACKET_TYPE.HEARTBEAT);this._send(e,t.seq)}else t.type==i.PACKET_TYPE.INTERNAL?(this.heartbeat(),this.emit("internal",new c(this,t,this.sendInternal.bind(this)))):n("Dropped internal packet!",t)}disconnect(e){for(let e in this[h])clearTimeout(this[h][e].timeout),this[h][e].reject("Peer disconnected!");this[h]={},clearTimeout(this._heartbeat),this[a].disconnect(e)}_send(e,t,s){return new Promise(((n,r)=>{this[a].isConnected()?(!d(t)&&t&&t>0&&e.setReplyTo(t),this[a].send(e),d(t)&&!0===t&&(this[h][e.seq]={time:(new Date).getTime(),resolve:n,reject:r,timeout:setTimeout((()=>{if(this[h][e.seq]){let t=this[h][e.seq];delete this[h][e.seq],this.disconnect("Missed reply timeout! Packet Type: "+o.TYPE._string(e.type)+" - "+e.seq),t.reject("Timeout!")}}),s||this[a].options.replyTimeout)}),e.type!=i.PACKET_TYPE.HEARTBEAT&&this.heartbeat()):r("Cannot send message. Peer is disconnected")}))}_recvForward(e){this[a].onPacket(this[a].peer,e.msg)}_resolveReply(e){if(e.seq*=-1,this[h][e.seq]){const t=this[h][e.seq];return delete this[h][e.seq],clearTimeout(t.timeout),t.resolve(new c(this,e,(()=>{n("Cannot reply to a reply packet!")}))),!0}return!1}}},288:(e,t,s)=>{const n=s(954)("AnyProtocol"),i=s(267),r=s(373),o=s(558),c=s(661),a=s(555),h=s(501),l=Symbol("secret key"),u=Symbol("private key"),d=Symbol("nonce");e.exports=class extends i{constructor(e,t,s){super(),this._seq=0,this[l]=null,this[u]=null,this[d]=null,this.peerID=t.id,this.peer=t,this.options=Object.assign({replyTimeout:3e4,heartbeatTimeout:5e3,heartbeatInterval:5e3},s),this.connectionID=this.peer.connectionID,this.anysocket=e,this._packetQueue=r(this,this.processPacketQueue.bind(this),1),this._linkPacketQueue=r(this,this.processLinkPacketQueue.bind(this),1),this._recvPacketQueue=r(this,this.processRecvPacketQueue.bind(this),1),this._packets={},this.changeState(h.PROTOCOL_STATES.ESTABLISHED),this.ENCRYPTION_STATE=h.PROTOCOL_ENCRYPTION.PLAIN,this.peer.on("message",((e,t)=>{this._recvPacketQueue.push([e,t])})),this.peer.isClient()&&!this.peerID&&(this.changeState(h.PROTOCOL_STATES.AUTHING),this.send(o.data({id:this.anysocket.id}).setType(o.TYPE.AUTH))),this.peerID&&this.changeState(h.PROTOCOL_STATES.CONNECTED)}isProxy(){return!!this.peer.isProxy}isConnected(){return this.state!=h.PROTOCOL_STATES.DISCONNECTED}send(e){return 0==e.seq&&e.setSeq(this._getSeq()),new Promise(((t,s)=>{const n=e=>{this.disconnect(e),s(e)};-1!=[o.TYPE.INTERNAL,o.TYPE.LINK,o.TYPE.HEARTBEAT,o.TYPE.FORWARD].indexOf(e.type)&&this.state!=h.PROTOCOL_STATES.CONNECTED?this._linkPacketQueue.push({packet:e,resolve:t,reject:n}):this._send(e,t,n)}))}_send(e,t,s){n(this.peerID,">>>>",o.TYPE._string(e.type),e.seq),e.serialize(h.MAX_PACKET_SIZE,this._encrypt.bind(this)).then((e=>{for(let n=0;n<e.length;n++){const i={packet:e[n],reject:s};n==e.length-1&&(i.resolve=t),this._packetQueue.push(i)}})).catch(s)}forward(e){return new Promise(((t,s)=>{this._packetQueue.push({packet:this._encodeForwardPacket(e.to,e.from,e.msg),resolve:t,reject:s})}))}e2e(){c.generateAESKey().then((e=>{this[u]=e.private,this[d]=e.nonce,this.changeState(h.PROTOCOL_STATES.SWITCHING_PROTOCOL),this.send(o.data({type:h.PROTOCOL_ENCRYPTION.E2EE,key:e.public,nonce:e.nonce}).setType(o.TYPE.SWITCH))})).catch((e=>{this.disconnect(e)}))}onPacket(e,t){return new Promise(((e,s)=>{let i=!0;if(o.isForwardPacket(t))this.emit("forward",this.peerID,this._decodeForwardPacket(t)),e();else{let s=o.getSeq(t);this._packets[s]||(this._packets[s]=o.buffer());let r=this._packets[s];r.deserialize(t,this._decrypt.bind(this)).then((t=>{if(n(this.peerID,"<<<<",o.TYPE._string(r.type),r.seq),t){switch(delete this._packets[s],this.state){case h.PROTOCOL_STATES.ESTABLISHED:if(r.type==o.TYPE.AUTH){if(i=!1,!r.data.id)return this.disconnect("Invalid Auth Packet!");this.peerID=r.data.id,this.send(o.data({id:this.anysocket.id}).setType(o.TYPE.AUTH)).then((()=>{this.changeState(h.PROTOCOL_STATES.CONNECTED),this.emit("ready",this)})),e()}break;case h.PROTOCOL_STATES.AUTHING:if(r.type==o.TYPE.AUTH){if(i=!1,this.changeState(h.PROTOCOL_STATES.CONNECTED),!r.data.id)return this.disconnect("Invalid Auth Packet!");this.peerID=r.data.id,this.emit("ready",this),e()}break;case h.PROTOCOL_STATES.CONNECTED:r.type==o.TYPE.LINK?(i=!1,this.emit("message",this,{seq:r.seq,data:r.data}),e()):r.type==o.TYPE.INTERNAL?(i=!1,this.emit("internal",this,{seq:r.seq,type:r.type,data:r.data}),e()):r.type==o.TYPE.SWITCH?(i=!1,c.generateAESKey().then((t=>(this[u]=t.private,this[d]=r.data.nonce+t.nonce,c.getAESSessionKey(this[d],this.peerID,0).then((s=>(this[d]=s,c.computeAESsecret(this[u],r.data.key).then((s=>{this[l]=s,this.send(o.data({type:h.PROTOCOL_ENCRYPTION.E2EE,key:t.public,nonce:t.nonce}).setType(o.TYPE.SWITCH)).then((()=>{this.ENCRYPTION_STATE=h.PROTOCOL_ENCRYPTION.E2EE,this.changeState(h.PROTOCOL_STATES.CONNECTED),this.emit("e2e",this),e()}))})))))))).catch((e=>{this.disconnect(e)}))):r.type==o.TYPE.HEARTBEAT&&(i=!1,this.emit("internal",this,{seq:r.seq,type:r.type,data:r.data}),e());break;case h.PROTOCOL_STATES.SWITCHING_PROTOCOL:r.type==o.TYPE.SWITCH?(i=!1,this[d]=this[d]+r.data.nonce,c.getAESSessionKey(this[d],this.anysocket.id,0).then((t=>(this[d]=t,c.computeAESsecret(this[u],r.data.key).then((t=>{this[l]=t,this.ENCRYPTION_STATE=h.PROTOCOL_ENCRYPTION.E2EE,this.changeState(h.PROTOCOL_STATES.CONNECTED),this.emit("e2e",this),e()}))))).catch((e=>{this.disconnect(e)}))):(r.type==o.TYPE.INTERNAL||r.type==o.TYPE.HEARTBEAT)&&(i=!1,this.emit("internal",this,{seq:r.seq,type:r.type,data:r.data}),e());break;case h.PROTOCOL_STATES.DISCONNECTED:i=!1,e()}i&&n("Invalid packet received! RECV:",r)}else e()}))}}))}changeState(e){switch(this.state=e,this.state){case h.PROTOCOL_STATES.ESTABLISHED:case h.PROTOCOL_STATES.AUTHING:this._linkPacketQueue.pause();break;case h.PROTOCOL_STATES.CONNECTED:this._linkPacketQueue.resume();break;case h.PROTOCOL_STATES.SWITCHING_PROTOCOL:this._linkPacketQueue.pause();break;case h.PROTOCOL_STATES.DISCONNECTED:this._packetQueue.pause(),this._packetQueue.kill(),this._linkPacketQueue.pause(),this._linkPacketQueue.kill()}}disconnect(e){this.changeState(h.PROTOCOL_STATES.DISCONNECTED),this.isProxy()?this.anysocket.unproxy(this.peer.id,this.peer.socket.id,e):this.peer.disconnect(e)}processPacketQueue(e,t){this.peer.send(e.packet).then((()=>{e.resolve&&e.resolve(),t(null,null)})).catch((s=>{e.reject(s),this._packetQueue.kill(),t(null,null)}))}processLinkPacketQueue(e,t){this._send(e.packet,e.resolve,e.reject),t(null,null)}processRecvPacketQueue(e,t){this.onPacket(...e).then((()=>{t(null,null)}))}_encrypt(e,t){return new Promise((s=>{switch(this.ENCRYPTION_STATE){case h.PROTOCOL_ENCRYPTION.PLAIN:s(e);break;case h.PROTOCOL_ENCRYPTION.E2EE:c.getAESSessionKey(this[l],this[d],t).then((t=>c.encryptAES(t,e).then(s))).catch((e=>{this.disconnect(e)}));break;default:throw new Error("Encryption state '"+this.ENCRYPTION_STATE+"' not implemented!")}}))}_decrypt(e,t){return new Promise((s=>{switch(this.ENCRYPTION_STATE){case h.PROTOCOL_ENCRYPTION.PLAIN:s(e);break;case h.PROTOCOL_ENCRYPTION.E2EE:c.getAESSessionKey(this[l],this[d],t).then((t=>c.decryptAES(t,e).then(s))).catch((e=>{this.disconnect(e)}));break;default:throw new Error("Encryption state '"+this.ENCRYPTION_STATE+"' not implemented!")}}))}_encodeForwardPacket(e,t,s){return o.TYPE.FORWARD+a.packHex(e)+a.packHex(t)+s}_decodeForwardPacket(e){return{to:a.unpackHex(e.substr(1,16)),from:a.unpackHex(e.substr(17,16)),msg:e.substr(33)}}_getSeq(){return this._seq>=32767&&(this._seq=0),this._seq++,this._seq}}},100:(e,t,s)=>{const n=s(954)("AnySocket"),i=s(267),r=s(661),o=s(501),c=Symbol("peers connected"),a=Symbol("ready peers"),h=Symbol("transports"),l=Symbol("onForward"),u=Symbol("onPeerConnected"),d=Symbol("onPeerReady"),p=Symbol("onPeerDisconnected"),T=Symbol("onPeerInternalMessage"),E=Symbol("findTransport"),y=s(155),m=s(288),P=s(366);class f extends i{constructor(){return super(),this.id=r.uuidv4(),n("AnySocketID:",this.id),this[c]={},this[a]={},this[h]={},this}filter(e){}send(e,t){return t=t||!1,new Promise(((s,n)=>{const i=[];for(let r in this[a])r=this[a][r],i.push(r.send(e,t)),Promise.all(i).then(s).catch(n)}))}setRPC(e){this.rpc=e}canProxy(e,t){return!1}proxy(e,t){return new Promise(((s,n)=>{e!=t&&e!=this.id?this[a][t].isProxy()?n("Cannot proxy via a proxy! atm... :)"):this[a][t].sendInternal({type:o.INTERNAL_PACKET_TYPE.PROXY,action:"proxy",id:e},!0).then((i=>{if(i.msg.ok&&!this[a][e]){let n=new m(this,new P(!0,this.id,e,this[a][t]),this[a][t].options);this[d](n),s(this[a][e])}else n("Cannot proxy!")})).catch(n):n("Cannot proxy loopback!")}))}unproxy(e,t,s){s=s||"Proxy Connection Closed",this[a][e]&&this[a][e].isProxy()&&(this[a][t].sendInternal({type:o.INTERNAL_PACKET_TYPE.PROXY,action:"unproxy",id:e}),this[p](this[a][e],s))}hasPeer(e){return!!this[a][e]}hasDirectPeer(e){return!(!this[a][e]||this[a][e].isProxy())}server(e,t){return this.listen(e,t)}listen(e,t){if("number"==typeof t&&(t={port:t}),t.ip=t.ip||"0.0.0.0",!t.port)throw new Error("Invalid port!");let s=this[E](e);return s=new s("server",t),this[h][s.id]=s,s.on("connected",(e=>{this[u](e,s.options)})),s.on("disconnected",((e,t)=>{this[p](e,t)})),s.listen()}connect(e,t,s,i){i=Object.assign(i||{},{ip:t,port:s});let r=this[E](e);return r=new r("client",i),r.on("connected",(e=>{this[h][r.id]=r,this[u](e,r.options),n("Transports Added",r.id,Object.keys(this[h]).length)})),r.on("disconnected",((e,t)=>{this[h][r.id].stop(),delete this[h][r.id],this[p](e,t),n("Transports left",r.id,Object.keys(this[h]).length)})),r.connect()}stop(){return new Promise(((e,t)=>{const s=[];for(let e in this[h])s.push(this[h][e].stop());Promise.all(s).then((()=>{this[c]={},this[a]={},this[h]={},e()})).catch((e=>{throw e}))}))}[E](e){for(let t in f.Transport)if(f.Transport.hasOwnProperty(t)&&f.Transport[t].scheme()==e)return f.Transport[t];throw new Error("Invalid scheme '"+e+"'")}[u](e,t){n("Peer connected");const s=new m(this,e,t);this[c][e.connectionID]=s,s.on("forward",this[l].bind(this)),s.once("ready",(e=>{this[d](e)}))}[l](e,t){if(this.id==t.to){if(!this[a][t.from])return void this[a][e].disconnect("Invalid forward packet! Client doesn't exist!");this[a][t.from]._recvForward(t)}else this.hasDirectPeer(t.to)?this[a][t.to].forward(t):console.error("FORWARD ERROR! We do not have the peer",t.to)}[d](e){n("Peer ready");const t=new y(e);this[a][e.peerID]=t,t.heartbeat(),t.on("message",(e=>{this.emit("message",e)})),t.on("e2e",(e=>{this.emit("e2e",e)})),t.on("heartbeat",(e=>{this.emit("heartbeat",e)})),t.on("internal",this[T].bind(this)),this.emit("connected",t)}[p](e,t){n("Peer disconnected",t,e.id);let s=null;if(this[c][e.connectionID]&&(s=this[c][e.connectionID].peerID,delete this[c][e.connectionID]),this[a][e.id]&&(s=e.id),s){const e=this[a][s];delete this[a][s];const n=e.getLinks();for(let t in n)n[t].sendInternal({type:o.INTERNAL_PACKET_TYPE.NETWORK,action:"disconnected",id:e.id}).catch((()=>{})),e.removeLink(n[t]),this[a][t]&&this[a][t].removeLink(e);e.disconnect(),this.emit("disconnected",e,t)}}[T](e){if(e.msg.type==o.INTERNAL_PACKET_TYPE.NETWORK){if("connected"==e.msg.action){if(!this[a][e.msg.id]){let t=new m(this,new P(!1,this.id,e.msg.id,this[a][e.peer.id]));this[d](t)}}else if("disconnected"==e.msg.action){if(!this[a][e.msg.id])return void e.peer.disconnect("Invalid proxy request!");this[p](this[a][e.msg.id],"Proxy Connection Closed")}}else if(e.msg.type==o.INTERNAL_PACKET_TYPE.PROXY){if("proxy"==e.msg.action){if(!this.canProxy(e.peer.id,e.msg.id)||!this[a][e.msg.id])return void e.peer.disconnect("Invalid proxy request!");if(this[a][e.msg.id].isProxy())return void e.reply({ok:!1});this[a][e.msg.id].addLink(this[a][e.peer.id]),this[a][e.peer.id].addLink(this[a][e.msg.id]),this[a][e.msg.id].sendInternal({type:o.INTERNAL_PACKET_TYPE.NETWORK,action:"connected",id:e.peer.id}),e.reply({ok:!0})}else if("unproxy"==e.msg.action){if(!this.canProxy(e.peer.id,e.msg.id)||!this[a][e.msg.id])return void e.peer.disconnect("Invalid proxy request!");this[a][e.msg.id].removeLink(this[a][e.peer.id]),this[a][e.peer.id].removeLink(this[a][e.msg.id]),this[a][e.msg.id].sendInternal({type:o.INTERNAL_PACKET_TYPE.NETWORK,action:"disconnected",id:e.peer.id})}}else if(e.msg.type==o.INTERNAL_PACKET_TYPE.RPC){let t=!1,s=this.rpc;for(let n in e.msg.method)if(t=s,s=s[e.msg.method[n]],!s)break;if(t&&s&&"function"==typeof s)try{Promise.resolve(s.apply(t,e.msg.params)).then((t=>{e.reply(t)})).catch((t=>{e.reply({error:t,code:500})}))}catch(t){e.reply({error:t.message,code:500})}else e.reply({error:"Method not found",code:404})}else e.msg.type==o.INTERNAL_PACKET_TYPE.RPC_NOTIFY?console.log("RPC_NOTIFY",e.msg):e.peer.disconnect("Invalid internal message")}}e.exports=f},558:(e,t,s)=>{const n=s(555),i=s(501),r=(Symbol("buffer"),e=>n.unpackInt16(e.substr(2,2))),o={};class c{constructor(e){this.seq=0,this.type=0,this.buffer=[],this.data=null,e&&(this.data=e)}setType(e){return this.type=e,this}setSeq(e){return this.seq=e,this}setReplyTo(e){return e&&(this.seq=-e),this}async serialize(e,t){e=e||Number.MAX_SAFE_INTEGER;let s=[JSON.stringify(this.data)];s[0].length>e&&(o[e]=o[e]||new RegExp("(.{1,"+e+"})","g"),s=s[0].match(o[e]));for(let e=0;e<s.length;e++)s[e]=(e==s.length-1?i.PACKET_LENGTH.FULL:i.PACKET_LENGTH.PARTIAL).toString()+this.type.toString()+n.packInt16(this.seq)+await t(s[e],Math.abs(this.seq));return s}async deserialize(e,t){t=t||(e=>Promise.resolve(e));const s=e.substr(0,1)==i.PACKET_LENGTH.FULL;if(this.type=e.substr(1,1),this.seq=r(e),this.buffer.push(await t(e.substr(4),Math.abs(this.seq))),s){try{this.buffer=this.buffer.join("");let e=JSON.parse(this.buffer);this.buffer=[],this.data=e}catch(e){this.data=null}return!0}return!1}}e.exports={data:e=>new c(e=e||{}),buffer:()=>new c,getSeq:e=>r(e),isForwardPacket:e=>e.substr(0,1)==i.PACKET_TYPE.FORWARD,TYPE:i.PACKET_TYPE}},366:(e,t,s)=>{const n=s(586),i=s(162);e.exports=class extends n{constructor(e,t,s,n){super(n),this.id=s,this.anysocketID=t,this.type=e?i.TYPE.CLIENT:i.TYPE.SERVER,this.isProxy=!0,this.init()}onConnect(){}send(e){return new Promise(((t,s)=>{try{this.socket.forward({to:this.id,from:this.anysocketID,msg:e}),t()}catch(e){s(e)}}))}onDisconnect(){}}},501:e=>{const t={PACKET_TYPE:{AUTH:1,INTERNAL:2,LINK:3,SWITCH:4,HEARTBEAT:5,FORWARD:6},PACKET_LENGTH:{FULL:1,PARTIAL:2},INTERNAL_PACKET_TYPE:{NETWORK:1,PROXY:2,RPC:3,RPC_NOTIFY:4},PROTOCOL_STATES:{ESTABLISHED:0,AUTHING:1,CONNECTED:2,SWITCHING_PROTOCOL:3,DISCONNECTED:4},PROTOCOL_ENCRYPTION:{PLAIN:1,E2EE:2},MAX_PACKET_SIZE:524288};for(let e in t)t[e]._string=s=>{for(let n in t[e])if(t[e][n]==s)return n;return s};e.exports=t},510:(e,t,s)=>{const n=s(147),i=s(20);e.exports=new class{uuidv4(){return"xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx".replace(/[xy]/g,(function(e){const t=16*Math.random()|0;return("x"==e?t:3&t|8).toString(16)}))}generateAESKey(){return new Promise((async(e,t)=>{let s=await n.createECDH("secp521r1"),r=await s.generateKeys();e({private:s,public:i.bufferToString(r),nonce:i.bufferToHex(n.randomBytes(32))})}))}computeAESsecret(e,t){return new Promise((async(s,n)=>{let r=await e.computeSecret(i.bufferFromString(t),null,"hex");r=r.substr(0,128),s(r)}))}getAESSessionKey(e,t,s){return new Promise((async(r,o)=>{t=t+"_"+s,e=await n.pbkdf2Sync(e,t,1,32,"sha256"),r(e=i.bufferToHex(e))}))}encryptAES(e,t){return new Promise(((s,r)=>{try{let r=n.randomBytes(16),o=n.createCipheriv("aes-256-cbc",i.bufferFromHex(e),r),c=o.update(t);c=Buffer.concat([c,o.final()]);let a=r.toString("hex")+c.toString("hex");this.decryptAES(e,a),s(a)}catch(e){r(e)}}))}decryptAES(e,t){return new Promise(((s,r)=>{try{let r=Buffer.from(t.substr(0,32),"hex"),o=Buffer.from(t.substr(32),"hex"),c=n.createDecipheriv("aes-256-cbc",i.bufferFromHex(e),r),a=c.update(o);a=Buffer.concat([a,c.final()]),s(a.toString())}catch(e){r(e)}}))}}},586:(e,t,s)=>{const n=s(267),i=s(661),r=s(162);e.exports=class extends n{constructor(e){super(),this.connectionID=i.uuidv4(),this.connected=!0,this.socket=e,this.type=r.TYPE.NONE,this.inited=!1}init(){this.inited||(this.inited=!0,this.onConnect(),this.emit("connected",this))}isClient(){if(this.type==r.TYPE.NONE)throw new Error("Invalid transport type!!!");return this.type==r.TYPE.CLIENT}disconnect(e){this.connected&&(this.connected=!1,this.onDisconnect(),this.emit("disconnected",this,e))}send(e){throw new Error("send() must be implemented")}onConnect(){throw new Error("onConnect() must be implemented")}onDisconnect(){throw new Error("onDisconnect() must be implemented")}}},162:(e,t,s)=>{const n=s(267),i=s(661);class r extends n{constructor(e,t){super(),this.id=i.uuidv4(),this.options=Object.assign({},t),this.type=e,this.peers=new Map,this.started=!1}listen(){return new Promise(((e,t)=>{this.started?e():this.onListen().then((()=>{this.started=!0,e()})).catch((e=>{t(e)}))}))}connect(){return new Promise(((e,t)=>{this.started?e():this.onConnect().then((()=>{this.started=!0,e()})).catch((e=>{t(e)}))}))}stop(){return new Promise(((e,t)=>{if(this.started){this.started=!1;for(const e of this.peers.values())e.disconnect("Local Connection Closed");this.onStop().then((()=>{e()})).catch((e=>{t(e)}))}else e()}))}addPeer(e){e.type=this.type,e.on("connected",(()=>{this.peers.set(e.connectionID,e),this.emit("connected",e)})),e.on("disconnected",((e,t)=>{this.peers.delete(e.connectionID),this.emit("disconnected",e,t)})),e.init()}onConnect(){throw new Error("onConnect() must be implemented")}onListen(){throw new Error("onListen() must be implemented")}onStop(){throw new Error("onStop() must be implemented")}}var o,c,a;a=()=>{throw new Error("static scheme() must be implemented")},(c="scheme")in(o=r)?Object.defineProperty(o,c,{value:a,enumerable:!0,configurable:!0,writable:!0}):o[c]=a,e.exports=r,r.TYPE={CLIENT:"client",SERVER:"server"}},818:(e,t,s)=>{const n=s(586);e.exports=class extends n{constructor(){super(),this.isLocal=!0}onConnect(){}send(e){return new Promise(((t,s)=>{try{setImmediate((()=>{this.emit("message",this,e)})),t()}catch(e){s(e)}}))}onDisconnect(){}}},870:(e,t,s)=>{const n=s(162),i=s(818);e.exports=class extends n{constructor(e,t){super(e,t)}static scheme(){return"local"}onListen(){return new Promise(((e,t)=>{this.addPeer(new i),e()}))}onConnect(){return new Promise(((e,t)=>{t("Only listening is supported!")}))}onStop(){return new Promise(((e,t)=>{e()}))}}},683:(e,t,s)=>{const n=s(586);e.exports=class extends n{onConnect(){this.socket.on("close",(()=>{this.disconnect("Remote Connection Closed")})),this.socket.on("error",(e=>{this.emit("error",this,e)})),this.socket.on("message",(e=>{this.emit("message",this,e)}))}send(e){return new Promise(((t,s)=>{try{this.socket.send(e),t()}catch(e){s(e)}}))}onDisconnect(){this.socket&&(this.socket.close(),this.socket=null)}}},866:(e,t,s)=>{const n=s(162),i=s(683),r=s(966);e.exports=class extends n{constructor(e,t){super(e,t)}static scheme(){return"ws"}onListen(){return new Promise(((e,t)=>{this.ws=new r.Server({port:this.options.port,host:this.options.ip}),this.ws.on("connection",(e=>{this.addPeer(new i(e))})),this.ws.on("error",(e=>{t(e)})),this.ws.on("listening",(()=>{e()}))}))}onConnect(){return new Promise(((e,t)=>{let s=new r("ws://"+this.options.ip+":"+this.options.port+"/");s.on("open",(t=>{this.addPeer(new i(s)),e()})),s.on("error",(e=>{t(e)}))}))}onStop(){return new Promise(((e,t)=>{this.ws&&(this.ws.close(),this.ws=null),e()}))}}},373:(e,t,s)=>{"use strict";var n=s(650);function i(){}function r(){this.value=null,this.callback=i,this.next=null,this.release=i,this.context=null,this.errorHandler=null;var e=this;this.worked=function(t,s){var n=e.callback,r=e.errorHandler,o=e.value;e.value=null,e.callback=i,e.errorHandler&&r(t,o),n.call(e.context,t,s),e.release(e)}}e.exports=function(e,t,s){if("function"==typeof e&&(s=t,t=e,e=null),s<1)throw new Error("fastqueue concurrency must be greater than 1");var o=n(r),c=null,a=null,h=0,l=null,u={push:function(s,n){var r=o.get();r.context=e,r.release=d,r.value=s,r.callback=n||i,r.errorHandler=l,h===u.concurrency||u.paused?a?(a.next=r,a=r):(c=r,a=r,u.saturated()):(h++,t.call(e,r.value,r.worked))},drain:i,saturated:i,pause:function(){u.paused=!0},paused:!1,concurrency:s,running:function(){return h},resume:function(){if(u.paused){u.paused=!1;for(var e=0;e<u.concurrency;e++)h++,d()}},idle:function(){return 0===h&&0===u.length()},length:function(){for(var e=c,t=0;e;)e=e.next,t++;return t},getQueue:function(){for(var e=c,t=[];e;)t.push(e.value),e=e.next;return t},unshift:function(s,n){var r=o.get();r.context=e,r.release=d,r.value=s,r.callback=n||i,h===u.concurrency||u.paused?c?(r.next=c,c=r):(c=r,a=r,u.saturated()):(h++,t.call(e,r.value,r.worked))},empty:i,kill:function(){c=null,a=null,u.drain=i},killAndDrain:function(){c=null,a=null,u.drain(),u.drain=i},error:function(e){l=e}};return u;function d(s){s&&o.release(s);var n=c;n?u.paused?h--:(a===c&&(a=null),c=n.next,n.next=null,t.call(e,n.value,n.worked),null===a&&u.empty()):0==--h&&u.drain()}}},650:e=>{"use strict";e.exports=function(e){var t=new e,s=t;return{get:function(){var n=t;return n.next?t=n.next:(t=new e,s=t),n.next=null,n},release:function(e){s.next=e,s=e}}}}},t={};return function s(n){if(t[n])return t[n].exports;var i=t[n]={exports:{}};return e[n](i,i.exports,s),i.exports}(506)})();